# Задание № 13 - Новое
## Организация компьютерных сетей. Адрессация.


### **О задании**


В 13-ом задании нам потребуеться умение работать с ip адрессами и шлюзом для кодирования этого ip. 

Нам предстоит:

1. [Восстановить ip-адрес](https://inf-ege.sdamgia.ru/test?theme=345)
2. [Подсчет количества адресов в сети](https://inf-ege.sdamgia.ru/test?theme=348)
3. [Восстановить url](https://inf-ege.sdamgia.ru/test?theme=255)
4. [Определение адреса сети](https://inf-ege.sdamgia.ru/test?theme=253)
5. [Определение маски](https://inf-ege.sdamgia.ru/test?theme=254)



### **Варианты решения**

Пример кода находиться в [файле](task13.py)


Если вам попалось востановление ip адрес, то вам главное понимать, что адрес состоит из 4-х чисел, не превышающих 255, разделенных точками.

К примеру:
```bash
192.168.36.18
```

Соответсвенно для решения подобных заданий нужно просто подобрать нужные кусочки следуя правилу выше.

![image](/other/image-13-1.png)

Здесь мы видим, что под буквой *Г* у нас досточное число для окончания. Другими словами буква *Г* будет в конце.

Буква *А* будет предпоследней, так как числа больше 255 больше не может быть.

Соответсвенно первой будет будет буква *Б*, а за ней буква *В*.

**Задание очень похоже на то, что было в ОГЭ по информатике.**


<br><br>

Если вы решаете задачу с подсчетом количества ip адресов, то скорее всего вас попросят определить под каким номером записан в сети компьютер с опрдеелнным ip:

![image](/other/image-13-2.png)

Решение не сложное.

Для начала нам нужно понимать, что в маске сети числа 255 определяют адрес сети, а все остальное саму концепцию. 

Для начала переведем из масви сети все числа после порядка чисел 255 в двоисный вид. Для этого я буду использовать `Python IDE`

![image](/other/image-13-3.png)

Здесь выделеные нули представляют собой свободные биты, которые можно заполнить другими ip адресами. Чуть выше я перевел последнее число из ip адресса, чтобы узнать его конечные биты.

Теперь та длина, которая выделена берем из последних бит нашего ip и переводим в десятичный вид.

![image](/other/image-13-4.png)

**Это и есть ответ.**


<br><br>


Если вам нужно востаность url, то это еще проще:

Нужно понимать, что url состоит из протокола, сервера и файла в таком порядке:

```bash
протокол://сервер/файл
```

**Этого досточно, чтобы решать данное задание.**

<br><br>

Если вам необходимо опеделить ip адрес сети, то вам необходимо просто произвести поразрядную конъюкцию ко всем числам в маске и узле.

Для этого в python можно использовать встроенный символ `&`

```bash
>>>240 & 137
>>>128
```

Таким образом вы сможете узнать полный ip адрес таким путем:

![image](/other/image-13-5.png)

Объеденяем все это и получаем ответ:

```bash
145.92.128.0
```

Можно даже код написать:

```python
ip = "145.92.137.88".split(".")
mask = "255.255.240.0".split(".")

answer = []

for i in range(len(ip)):
    answer.append(str(int(ip[i]) & int(mask[i])))

print('.'.join(answer))
```

<br><br>

Если вам необходимо определить маску сети, то тут нужно сделать тоэе самое, что мы делали для определения ip адреса сети, но наоборот.

```bash
узел - 224.128.112.142
адрес - 224.128.64.0
```

Можно заметить, что первые два числа не поменялись, значит первые 16 бит заполнены всеми 1, соответсвенно это числа 255.

Во втором и третьем случае можно понять, что значения поменялись.

В четвертом байте сорее все все 0, так как на конце адреса стоит 0.

А вот в третьем байте нам нужно посчитать:

переводим оба числа в двоичное представление и начинаем анализировать: 

при каких двоичных значениях
маски поразрядная конъюкция с ip адресом узла даст такое значение как ip адрес сети.

Это задание посложнее, но все еще допускает легкое и быстрое решение.

<br><br>

Решение для ДЕМО версии:

1. Для начала импортируем модуль `ipaddress` из python:
   ```python
    from ipaddress import *
   ```

    Таким образом мы импортировали все функции из данного модуля.

    Модуль является встроенным, поэтому он точно должен быть усатновлен на ЕГЭ.

2. Из модуля (в нашем случае) потребуеться одна функция - `ip_network()`, которая в качестве параметра принимает строку вида -> ```'ip-адресс/шлюз'```. В итоге мы получим иттерируемый объект, который можно перебрать в цикле:

```python
for ip in ip_network('192.168.32.160/255.255.255.240'):
    ...
```

Если посмотреть на то, что выводиться в качестве значения для *ip*, то получим, что-то на подобии такого:
```bash
192.168.32.160
192.168.32.161
192.168.32.162
192.168.32.163
192.168.32.164
192.168.32.165
192.168.32.166
192.168.32.167
192.168.32.168
192.168.32.169
192.168.32.170
192.168.32.171
192.168.32.172
192.168.32.173
192.168.32.174
192.168.32.175
```

Это все возможные ip адресса в данной сети.

**Получаеться, что уже на этом моменте мы можем точно сказать какое максимальное количество ip адрессов може быть в этой сети.**

3. Далее по заданию состовляем условие для решения:

```python
if bin(int(ip))[2:].count("1") % 2 == 0:
    count += 1
```

Думаю здесь все понятно: 

Если количество единиц в бинарном(двоичном) представлении числа четна, то посчитать его.


4. Выводим ответ:
   
```python
print(count)
```
